# 复合类型

## 分类

 | 类型 | 名称 | 长度 | 默认值 | 说明 |
 | ---- | ---- | ---- | ---- | ---- |
 | pointer	| 指针		| | nil	| |
 | array	  | 数组		| | 0	  | |
 | slice	  | 切片 		| | nil	| 引⽤类型 |
 | map	    | 字典		| | nil	| 引⽤类型 |
 | struct	  | 结构体	 | | | &ensp; |

---

 ## 指针

 指针是一个代表着某个内存地址的值。这个内存地址往往是在内存中存储的另一个变量的值的起始位置。Go 语言对指针的支持介于 Java 语言和 C/C++ 语言之间，它既没有想 Java 语言那样取消了代码对指针的直接操作的能力，也避免了 C/C++ 语言中由于对指针的滥用而造成的安全和可靠性问题。


 #### 基本操作

Go语言虽然保留了指针，但与其它编程语言不同的是：

- 默认值 `nil`，没有 `NULL` 常量

- 操作符 "`&`" 取变量地址， "`*`" 通过指针访问目标对象

- 不支持指针运算，不支持 "`->`" 运算符，直接⽤ "`.`" 访问目标成员

```
func main() {
    var a int = 10              //声明一个变量，同时初始化
    fmt.Printf("&a = %p\n", &a) //操作符 "&" 取变量地址

    var p *int = nil            //声明一个变量p, 类型为 *int, 指针类型
    p = &a
    fmt.Printf("p = %p\n", p)
    fmt.Printf("a = %d, *p = %d\n", a, *p)

    *p = 111                    //*p操作指针所指向的内存，即为a
    fmt.Printf("a = %d, *p = %d\n", a, *p)
}
```


#### new 函数

表达式 `new(T)` 将创建一个 `T` 类型的匿名变量，所做的是为 `T` 类型的新值分配并清零一块内存空间，然后将这块内存空间的地址作为结果返回，而这个结果就是指向这个新的 `T` 类型值的指针值，返回的指针类型为 `*T`。

```
func main() {
    var p1 *int
    p1 = new(int)              //p1为*int 类型, 指向匿名的int变量
    fmt.Println("*p1 = ", *p1) //*p1 =  0

    p2 := new(int) //p2为*int 类型, 指向匿名的int变量
    *p2 = 111
    fmt.Println("*p2 = ", *p2) //*p1 =  111
}
```

我们只需使用 `new()` 函数，无需担心其内存的生命周期或怎样将其删除，因为 Go 语言的内存管理系统会帮我们打理一切。


#### 指针做函数参数

```
func swap01(a, b int) {
    a, b = b, a
    fmt.Printf("swap01 a = %d, b = %d\n", a, b)
}

func swap02(x, y *int) {
    *x, *y = *y, *x
}

func main() {
    a := 10
    b := 20

    //swap01(a, b) //值传递
    swap02(&a, &b) //变量地址传递
    fmt.Printf("a = %d, b = %d\n", a, b)
}
```

---

## 数组




















































---


上一篇: [GO]()   &emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 下一篇: [GO]()
