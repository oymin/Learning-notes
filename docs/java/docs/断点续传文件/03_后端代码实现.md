# 后端实现

## 业务流程

### 服务端需要实现如下功能：

1、上传前检查上传环境

- 检查文件是否上传，已上传则直接返回。
- 检查文件上传路径是否存在，不存在则创建。

2、分块检查

- 检查分块文件是否上传，已上传则返回 true。
- 未上传则检查上传路径是否存在，不存在则创建。

3、分块上传

- 将分块文件上传到指定的路径。

4、合并分块

- 将所有分块文件合并为一个文件。
- 在数据库记录文件信息。

---

## 前端接口实现

### service 中的公共引用

```java
@Autowired
MediaFileRepository mediaFileRepository;
@Autowired
RabbitTemplate rabbitTemplate;

//上传文件根目录
@Value("${xc-service-manage-media.upload-location}")
String uploadPath;
```

公共方法

```java
/**
 * 根据文件md5得到文件路径
 * 规则：
 * 一级目录：md5的第一个字符
 * 二级目录：md5的第二个字符
 * 三级目录：md5
 * 文件名：md5+文件扩展名
 *
 * @param fileMd5 文件md5值
 * @param fileExt 文件扩展名
 * @return 文件路径
 */
private String getFilePath(String fileMd5, String fileExt) {
    String filePath = uploadPath + fileMd5.substring(0, 1) + "/" + fileMd5.substring(1, 2) +
            "/" + fileMd5 + "/" + fileMd5 + "." + fileExt;
    return filePath;
}

//得到文件目录相对路径，路径中去掉根目录
private String getFileFolderRelativePath(String fileMd5, String fileExt) {
    String filePath = fileMd5.substring(0, 1) + "/" + fileMd5.substring(1, 2) + "/" +
            fileMd5 + "/";
    return filePath;
}

//得到文件所在目录
private String getFileFolderPath(String fileMd5) {
    String fileFolderPath = uploadPath + fileMd5.substring(0, 1) + "/" + fileMd5.substring(1, 2)
            + "/" + fileMd5 + "/";
    return fileFolderPath;
}

//创建文件目录
private boolean createFileFold(String fileMd5) {
    //创建上传文件目录
    String fileFolderPath = getFileFolderPath(fileMd5);
    File fileFolder = new File(fileFolderPath);
    if (!fileFolder.exists()) {
        //创建文件夹
        boolean mkdirs = fileFolder.mkdirs();
        return mkdirs;
    }
    return true;
}

//得到块文件所在目录
private String getChunkFileFolderPath(String fileMd5) {
    String chunkFileFolderPath = this.getFileFolderPath(fileMd5) + "chunk" + "/";
    return chunkFileFolderPath;
}
```

---

### 1. 上传前检查上传环境

- 检查文件是否上传，已上传则直接返回。
- 检查文件上传路径是否存在，不存在则创建

```java
//文件上传前的注册，检查文件是否存在
public ResponseResult register(String fileMd5, String fileName, Long fileSize, String minetype, String fileExt) {
    //检查文件在磁盘上是否存在
    String fileFolderPath = this.getFileFolderPath(fileMd5); //MD5做为文件所在的目录路径
    String filePath = this.getFilePath(fileMd5, fileExt); //文件的路径
    File file = new File(filePath);
    boolean exists = file.exists();
    //经检查文件信息在mongoDB中是否存在
    Optional<MediaFile> optional = mediaFileRepository.findById(fileMd5);
    if (exists && optional.isPresent()) {
        //文件存在，前端提示文件已存在
        ExceptionCast.cast(MediaCode.UPLOAD_FILE_REGISTER_EXIST);
    }
    //文件不存在时，检查文件所在目录是否存在，不存在则创建
    File fileFolder = new File(fileFolderPath);
    if (!fileFolder.exists()) {
        fileFolder.mkdirs();
    }

    return ResponseResult.SUCCESS();
}
```

### 2. 分块检查

- 检查分块文件是否上传，已上传则返回 true。
- 未上传则检查上传路径是否存在，不存在则创建。

```java
/**
 * 校验分块文件是否存在
 * @param fileMd5    md5值
 * @param chunkIndex 块的下标
 * @param chunkSize  快的大小
 * @return
 */
public CheckChunkResult checkChunk(String fileMd5, Integer chunkIndex, Integer chunkSize) {
    //得到分块文件的所在目录
    String chunkFileFolderPath = this.getChunkFileFolderPath(fileMd5);
    File chunkFile = new File(chunkFileFolderPath + chunkIndex);
    //检查分块文件是否存在
    if (chunkFile.exists()) {
        return new CheckChunkResult(CommonCode.SUCCESS, true); //块文件存在
    }
    return new CheckChunkResult(CommonCode.SUCCESS, false); //块文件不存在
}
```

### 3. 分块上传

- 将分块文件上传到指定的路径。

```java
//上传分块
public ResponseResult uploadChunk(MultipartFile file, String fileMd5, Integer chunkIndex) {
    //得到分块文件所在的目录
    String chunkFileFolderPath = this.getChunkFileFolderPath(fileMd5);
    //拼接分块文件存储路径
    String chunkFilePath = chunkFileFolderPath + chunkIndex;
    //判断块文件所在目录是否存在
    File chunkFileFolder = new File(chunkFileFolderPath);
    if (!chunkFileFolder.exists()) {
        chunkFileFolder.mkdirs();
    }
    //得到上传文件的输入流
    InputStream is = null;
    FileOutputStream fos = null;
    try {
        is = file.getInputStream();
        fos = new FileOutputStream(new File(chunkFilePath));
        IOUtils.copy(is, fos);
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            is.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            fos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    return ResponseResult.SUCCESS();
}
```

### 4. 合并分块

- 将所有分块文件合并为一个文件。
- 在数据库记录文件信息

```java
//合并所有分块
public ResponseResult mergeChunks(String fileMd5, String fileName, Long fileSize, String minetype, String fileExt) {
    String chunkFileFolderPath = this.getChunkFileFolderPath(fileMd5); //得到分块文件所在目录
    File chunkFileFolder = new File(chunkFileFolderPath); //创建分块目录对象
    File[] fileArr = chunkFileFolder.listFiles(); //获取分块目录下所有分块文件
    List<File> fileList = Arrays.asList(fileArr);

    //创建一个合并文件
    String filePath = this.getFilePath(fileMd5, fileExt);
    File mergeFile = new File(filePath);

    //调用合并方法
    mergeFile = this.mergeFile(fileList, mergeFile);
    if (mergeFile == null) {
        ExceptionCast.cast(MediaCode.MERGE_FILE_FAIL);
    }

    //校验文件的md5值是否和前端传入的md5一致
    boolean checkFileMd5 = this.checkFileMd5(mergeFile, fileMd5);
    if (!checkFileMd5) {
        ExceptionCast.cast(MediaCode.MERGE_FILE_CHECKFAIL);
    }

    //将文件的信息你写入mongodb
    MediaFile mediaFile = new MediaFile();
    mediaFile.setFileId(fileMd5);
    //.....
    MediaFile save = mediaFileRepository.save(mediaFile);

    //向RabbitMQ发送视频处理消息
    //sendProcessVideoMsg(fileMd5); 

    return ResponseResult.SUCCESS();
}
```

#### 合并文件方法：

```java
//合并文件
private File mergeFile(List<File> fileList, File mergeFile) {
    try {
        if (mergeFile.exists()) {
            mergeFile.delete();
        } else {
            try {
                mergeFile.createNewFile();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        //对块文件排序
        Collections.sort(fileList, new Comparator<File>() {
            @Override
            public int compare(File o1, File o2) {
                if (Integer.parseInt(o1.getName()) > Integer.parseInt(o2.getName())) {
                    return 1;
                }
                return -1;
            }
        });

        RandomAccessFile raf_write = new RandomAccessFile(mergeFile, "rw");
        raf_write.seek(0);  //指针指向文件顶端
        byte[] bytes = new byte[1024];
        for (File file : fileList) {
            RandomAccessFile raf_read = new RandomAccessFile(file, "r");
            int len = -1;
            while ((len = raf_read.read(bytes)) != -1) {
                raf_write.write(bytes, 0, len);
            }
            raf_read.close();
        }
        raf_write.close();

        return mergeFile;

    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}
```

#### 校验文件的 md5 值

```java
//校验文件md5值
private boolean checkFileMd5(File file, String md5) {
    FileInputStream fis = null;
    try {
        fis = new FileInputStream(file);
        //得到文件md5
        String md5Hex = DigestUtils.md5Hex(fis);
        if (md5.equalsIgnoreCase(md5Hex)) {
            return true;
        }
    } catch (Exception e) {
        e.printStackTrace();
    }

    return false;
}
```
