# 什么是断点续传

断点续传指的是在下载或上传时，将下载或上传任务（一个文件或一个压缩包）人为的划分为几个
部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载，断点续传可以提高节省操作时间，提高用户体验性。

如下图：

![image](../../images/01.jpg)

上传流程如下：

1、上传前先把文件分成块

2、一块一块的上传，上传中断后重新上传，已上传的分块则不用再上传

3、各分块上传完成最后合并文件

> 本文前端使用 Html5 + WebUploader 组件

## 1. 文件分块与合并

### 1.1 文件分块

文件分块的流程如下：

1、获取源文件长度

2、根据设定的分块文件的大小计算出块数

3、从源文件读数据依次向每一个块文件写数据。

```java
//测试文件分块
@Test
public void testChunk() throws IOException {
    //源文件
    File file = new File("D:\\Develop2\\Test\\lucene.mp4");
    //块文件
    String chunkFileFolder = "D:\\Develop2\\Test\\chunks\\";
    File fileFolder = new File(chunkFileFolder);
    if (!fileFolder.exists()) {
        fileFolder.mkdirs();
    }
    //定义块文件大小
    long chunkFileSize = 1 * 1024 * 1024; //1M
    //分块数量
    long chunkFileNum = (long) Math.ceil(file.length() * 1.0 / chunkFileSize);
    if (chunkFileNum <= 0) {
        chunkFileNum = 1;
    }
    //创建读文件的对象
    RandomAccessFile raf_read = new RandomAccessFile(file, "r");
    byte[] bytes = new byte[1024];
    //分块
    for (int i = 0; i < chunkFileNum; i++) {
        //块文件
        File chunkFile = new File(chunkFileFolder + i);
        //创建写对象
        RandomAccessFile raf_write = new RandomAccessFile(chunkFile, "rw");
        //向快文件写入数据
        int len = -1;
        while ((len = raf_read.read(bytes)) != -1) {
            raf_write.write(bytes, 0, len);
            if (chunkFile.length() >= chunkFileSize) {
                break;
            }
        }
        raf_write.close();
    }
    raf_read.close();
}
```

### 1.2 文件合并

文件合并流程：

1、找到要合并的文件并按文件合并的先后进行排序。

2、创建合并文件

3、依次从合并的文件中读取数据向合并文件写入数

```java
//测试文件合并
@Test
public void testMerge() throws IOException {
    //块文件目录
    File chunkFileFolder = new File("D:\\Develop2\\Test\\chunks\\");
    //合并文件
    File mergeFile = new File("D:\\Develop2\\Test\\merge.mp4");
    if (mergeFile.exists()) {
        mergeFile.delete();
    }
    mergeFile.createNewFile();
    //用于写文件
    RandomAccessFile raf_write = new RandomAccessFile(mergeFile, "rw");
    //指针指向文件顶端
    raf_write.seek(0);
    byte[] bytes = new byte[1024];
    File[] fileArray = chunkFileFolder.listFiles();
    List<File> fileList = new ArrayList<>(Arrays.asList(fileArray));
    //文件从小到大排序
    Collections.sort(fileList, new Comparator<File>() {
        @Override
        public int compare(File o1, File o2) {
            if (Integer.parseInt(o1.getName()) < Integer.parseInt(o2.getName())) {
                return -1;
            }
            return 1;
        }
    });
    //合并文件
    for (File chunkFile : fileList) {
        RandomAccessFile raf_read = new RandomAccessFile(chunkFile, "r");
        int len = -1;
        while ((len = raf_read.read(bytes)) != -1) {
            raf_write.write(bytes, 0, len);
        }
        raf_read.close();
    }
    raf_write.close();

}
```
