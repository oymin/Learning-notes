# MySQL 事务

MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人 员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！

- 在 MySQL 中只有使用了 `Innodb` 数据库引擎的数据库或表才支持事务。

- 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。

- 事务用来管理 `insert`, `update`, `delete` 语句。

## 1. 事物的四个特性（ACID）

一般来说，事务是必须满足4个条件（ACID）。

**原子性（Atomicity）：** 一个事务（transaction）中的所有操作，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，，会被回滚（Rollback）到事务开始前的状态。

    拿转账来说，假设用户 A 和用户 B 两者的钱加起来一共是 20000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 20000，这就是事务的一致性。

**一致性（Consistency）：** 事务的执行使数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定。

**隔离性（Isolation）：** 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

**持久性（Durability）：** 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

## 2. 事务控制语句

- **BEGIN 或 START TRANSACTION**

    显式地开启一个事务；

- **COMMIT**

    也可以使用 COMMIT WORK，不过二者是等价的。

- **COMMIT**

    会提交事务，并使已对数据库 进行的所有修改成为永久性的；

- **ROLLBACK**

    有可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；

- **SAVEPOINT identifier**

    SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；

- **RELEASE SAVEPOINT identifier**

    删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；

- **ROLLBACK TO identifier**

    把事务回滚到标记点；

- **SET TRANSACTION**

    用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有 READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。

## 3. MYSQL 事务处理主要有两种方法

1、用 BEGIN, ROLLBACK, COMMIT 来实现

```sql
BEGIN       开始一个事务
ROLLBACK    事务回滚
COMMIT      事务确认
```

2、直接用 SET 来改变 MySQL 的自动提交模式:

```sql
SET AUTOCOMMIT=0    禁止自动提交
SET AUTOCOMMIT=1    开启自动提
```

## 4. 事务的4中隔离界别

事务的隔离级别有4种，由低到高分别为 `Read uncommitted` 、`Read committed` 、`Repeatable read` `、Serializable` 。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。下面通过事例一一阐述它们的概念与联系。

### 4.1 Read uncommitted（读未提交）

读未提交（脏读），顾名思义，就是一个事务可以读取另一个未提交事务的数据。

    例如：A 转给100元到 B 的账户，B 查看到账户有100元，但此时事务还没有提交，事务 B 使用了 A 未提交的撤销数据成为脏读。

### 4.2 Read committed（读已提交）

读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。

```text
eg：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的 UPDATE 修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。
```

```text
Analyse：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。
```

### 4.3 Repeatable read（重复读）

重复读（可避免脏读、不可重复读的发生。），就是在开始读取数据（事务开启）时，不再允许修改操作。

```text
eg：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。
```


```text
Analyse：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作
```

什么时候会出现幻读？

```text
    eg：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。

那怎么解决幻读问题？Serializable！

### 4.4 Serializable（序列化）

Serializable （可避免脏读、不可重复读、幻读的发生）是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

> 大多数数据库默认的事务隔离级别是 Read committed，比如 Sql Server , Oracle。
> Mysql 的默认隔离级别是 Repeatable read。

