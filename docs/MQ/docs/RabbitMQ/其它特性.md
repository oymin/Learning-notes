# RabbitMQ 其它特性

## Binding 绑定

- Exchange 和 Exchange、Queue 之间的连接关系
- Binding 中可以包含 RoutingKey 或者参数

## Queue 消息队列

消息队列，实际存储消息数据

### Queue 的属性

**Durability：** 是否持久化，Durable 是，Transient 否

**Auto delete：** 如选 yes，代表当最后一个监听被移除之后，该 Queue 会被自动删除

## Message 消息

- 服务器和应用程序之间传送的数据
- 本质上就是一段数据，由 Properties 和 Payload (Body) 组成

### Message 属性

```yml
type：             类型
app_id：           应用程序id
user_id：          用户id
headers：          自定义属性
priority：         消息的优先级
reply_to：         用于指定回复的队列的名称
timestamp：        消息的时间戳
expiration：       消息的失效时间
message_id：       消息id
cluster_id：       集群id
deliveryMode：     常用模式（1 非持久化，2 持久化）
content_type：     消息内容的类型
correlation_id：   关联id
content_encoding： 消息内容的编码格式
```

`headers` 自定义属性中对应的几个类型:

```yml
__ContentTypeId__ :     java.lang.Object
__TypeId__:             java.util.LinkedHashMap
__KeyTypeId__:          java.lang.Object
```

**生产端代码：**

```java
public class Producer {
    public static void main(String[] args) throws IOException, TimeoutException {
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost("192.168.194.151");
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost("/");
        Connection connection = connectionFactory.newConnection();
        Channel channel = connection.createChannel();

        HashMap<String, Object> headersMap = new HashMap<>();
        headersMap.put("my1", "111");

        //消息属性
        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder()
                //持久化模式
                .deliveryMode(2)
                .contentType("UTF-8")
                //过期时间
                .expiration("10000")
                //自定义属性
                .headers(headersMap)
                .build();

        String msg = "Hello RabbitMQ";
        for (int i = 0; i < 3; i++) {
            channel.basicPublish("", "test001", properties, msg.getBytes());
        }

        channel.close();
        connection.close();
    }
}
```

**消费端代码：**

```java
public class Consumer {
    public static void main(String[] args) throws IOException, TimeoutException {
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost("192.168.194.151");
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost("/");
        Connection connection = connectionFactory.newConnection();
        Channel channel = connection.createChannel();

        DefaultConsumer defaultConsumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                Map<String, Object> headers = properties.getHeaders();
                Object my1 = headers.get("my1");
                System.out.println("headers: " + my1);
                String msg = new String(body);
                System.out.println("接收到消息：" + msg);
            }
        };

        channel.basicConsume("test001", true, defaultConsumer);
    }
}
```

**测试结果：**

```text
headers: 111
接收到消息：Hello RabbitMQ
headers: 111
接收到消息：Hello RabbitMQ
headers: 111
接收到消息：Hello RabbitMQ
```

## Virtual Host 虚拟主机

- 虚拟地址，用于进行逻辑隔离，最上层的消息路由
- 一个 Virtual Host 里面可以有若干个 Exchange 和 Queue
- 同一个 Virtual Host 里面不能有相同名称的 Exchange 和 Queue
