# 指令参考

## assign

> ### 概要

```
<#assign name1=value1 name2=value2 ... nameN=valueN>
```
或
```
<#assign same as above... in namespacehash>
```
或
```
<#assign name>
  capture this
</#assign>
```
或
```
<#assign name in namespacehash>
  capture this
</#assign>
```

#### 这里

- `name：`变量的名字。 它不是表达式。而它可以写作是字符串，如果变量名包含保留字符这是很有用的， 比如 `<#assign "foo-bar" = 1>`。 请注意这个字符串没有展开插值(如`"${foo}"`)； 如果需要赋值一个动态创建的名字，那么不得不使用 这个技巧。

- `=：`赋值操作符。 它也可以是一个简写的赋值操作符(从 FreeMarker 2.3.23 版本开始)：` ++，--， +=，-=， *=，/=` 或 `%=`。比如 `<#assign x++>` 和 `<#assign x = x + 1>` 是一样的，并且 `<#assign x += 2>` 和 `<#assign x = x + 2>` 是相同的。 请注意， `++` 通常意味着算术加法 (对于非数字将会失败)，不像 `+` 或 `+=` 可以进行字符连接等重载操作。

- `value：` 存储的值。是表达式。

- `namespacehash：`(通过 `import`) 为命名空间创建的哈希表。是表达式。

> ### 描述

使用该指令你可以创建一个新的变量， 或者替换一个已经存在的变量。注意仅仅顶级变量可以被创建/替换 (也就是说你不能创建/替换 `some_hash.subvar`， 除了 `some_hash`)。

比如：变量 seq 存储一个序列：

```
<#assign seq = ["foo", "bar", "baz"]>
```

比如：变量 x 中存储增长的数字：

```
<#assign x++>
```

`assign` 指令在命名空间中创建变量

```
<#import "/mylib.ftl" as my>
<#assign bgColor="red" in my>
```

`assign` 的极端使用是当它捕捉它的开始标记和结束标记中间生成的输出时。 也就是说，在标记之间打印的东西将不会在页面上显示， 但是会存储在变量中。比如：

```
<#macro myMacro>foo</#macro>
<#assign x>
  <#list 1..3 as n>
    ${n} <@myMacro />
  </#list>
</#assign>
Number of words: ${x?word_list?size}
${x}
```

将会输出：

```
Number of words: 6
    1 foo
    2 foo
    3 foo
```

<font color="red">请注意，</font>你不应该使用它来往字符串中插入变量：

```
<#assign x>Hello ${user}!</#assign> <#-- BAD PRACTICE! -->
```

你可以这么来写：

```
<#assign x="Hello ${user}!">
```

---

## attempt, recover

### 概要

```
<#attempt>
  attempt block
<#recover>
  recover block
</#attempt>
```

#### 这里：

- `attempt block`：任意内容的模板块。这是会被执行的， 但是如果期间发生了错误，那么这块内容的输出将会回滚， 之后 `recover block` 就会被执行。

- `recover block`: 任意内容的模板块。 这个仅在 `attempt block` 执行期间发生错误时被执行。你可以在这里打印错误信息或其他操作。

`recover` 是强制的。 `attempt/recover` 可以嵌套在其他 `attempt block` 或 `recover block`中。

### 描述

如果你想让页面成功输出内容，尽管它在页面特定位置发生错误也这样， 那么这些指令就是有用的。如果一个错误在 `attempt block` 执行期间发生， 那么模板执行就会中止，但是 `recover block` 会代替 `attempt block` 执行。 如果在 `attempt block` 执行期间没有发生错误， 那么 `recover block` 就会忽略。 一个简单的示例如下：

```
Primary content
<#attempt>
  Optional content: ${thisMayFails}
<#recover>
  Ops! The optional content is not available.
</#attempt>
Primary content continued
```

如果 `thisMayFails` 变量不存在，将会输出：

```
Primary content
  Ops! The optional content is not available.
Primary content continued
```

如果 `thisMayFails` 变量存在而且值为 `123`，将会输出：

```
Primary content
  Optional content: 123
Primary content continued
```

---

## compress

### 概要

```
<#compress>
  ...
</#compress>
```

### 描述

当你使用了对空白不敏感的格式(比如HTML或XML) 时压缩指令对于移除多余的 空白 是很有用的。它捕捉在指令体(也就是在开始标签和结束标签中)中生成的内容， 然后缩小所有不间断的空白序列到一个单独的空白字符。 如果被替代的序列包含换行符或是一段空间，那么被插入的字符也会是一个 换行符。 开头和结尾的不间断的空白序列将会完全被移除。

```
<#assign x = "    moo  \n\n   ">
(<#compress>
  1 2  3   4    5
  ${moo}
  test only

  I said, test only

</#compress>)
```

将会输出：

```
(1 2 3 4 5
moo
test only
I said, test only)
```

---

## escape, noescape

### 概要

```
<#escape identifier as expression>
  ...
  <#noescape>...</#noescape>
  ...
</#escape>
```

### 描述

当你使用 `escape` 指令包围模板中的一部分时，在块中出现的插值 (`${...}`) 会和转义表达式自动结合。这是一个避免编写相似表达式的很方便的方法。 它不会影响在字符串形式的插值(比如在 `<#assign x = "Hello ${user}!">`)。而且，它也不会影响数值插值 (`#{...}`)。

```
<#escape x as x?html>
  First name: ${firstName}
  Last name: ${lastName}
  Maiden name: ${maidenName}
</#escape>
```

事实上它等同于：

```
  First name: ${firstName?html}
  Last name: ${lastName?html}
  Maiden name: ${maidenName?html}
```

### 非转义指令 noescape

有时需要暂时为一个或两个在转义区块中的插值关闭转义。你可以通过关闭， 过后再重新开启转义区块来达到这个功能，但是那么你不得不编写两遍转义表达式。 你可以使用非转义指令来替代：

```
<#escape x as x?html>
  From: ${mailMessage.From}
  Subject: ${mailMessage.Subject}
  <#noescape>Message: ${mailMessage.htmlFormattedBody}</#noescape>
  ...
</#escape>
```

和这个是等同的：

```
  From: ${mailMessage.From?html}
  Subject: ${mailMessage.Subject?html}
  Message: ${mailMessage.htmlFormattedBody}
  ...
```

转义可以被嵌套(尽管你不会在罕见的情况下来做)。 因此，你可以编写如下面代码(这个例子固然是有点伸展的， 正如你可能会使用 list 来迭代序列中的每一项， 但是我们现在所做的是阐述这个观点)的东西：

```
<#escape x as x?html>
  Customer Name: ${customerName}
  Items to ship:
  <#escape x as itemCodeToNameMap[x]>
    ${itemCode1}
    ${itemCode2}
    ${itemCode3}
    ${itemCode4}
  </#escape>
</#escape>
```

实际上和下面是等同的：

```
  Customer Name: ${customerName?html}
  Items to ship:
    ${itemCodeToNameMap[itemCode1]?html}
    ${itemCodeToNameMap[itemCode2]?html}
    ${itemCodeToNameMap[itemCode3]?html}
    ${itemCodeToNameMap[itemCode4]?html}
```

当你在嵌入的转义区块内使用非转义指令时，它仅仅不处理一个单独层级的转义。 因此，为了在两级深的转义区块内完全关闭转义，你需要使用两个嵌套的非转义指令。

---

## flush

### 概要

```
<#flush>
```

### 描述

当 FreeMarker 生成输出时，它通常不会立即发送到最终接收端 (比如web浏览器或最终的文件)，而是会将内容累积在缓冲区，发送一个大块的内容。 缓冲区的精确规则不是由 FreeMarker 决定的，而是由嵌入的软件决定的。 将缓冲区中累积的内容发送出去称为冲洗。尽管冲洗是自动发生的， 有时你想在模板处理时的一点强制执行，这就是 `flush` 指令要做的。如果需要在确定之处用到它，这是由程序员决定的，而不是设计师。

请注意， `flush` 告诉嵌入的软件我们想要冲洗， 那么也许就会决定忽略该请求。这不由 FreeMarker 之手控制。

> 冲洗简单调用当前使用 `java.io.Writer` 实例的 `flush()` 方法。 整个缓冲区和冲洗机制由 `Writer`(就是传递给 `Template.process` 方法的参数)实现； FreeMarker不用来处理它。

---

## ftl

### 概要

```
<#ftl param1=value1 param2=value2 ... paramN=valueN>
```

#### 这里：

- `param1`, `param2` 等： 参数的名字，不是表达式。允许的参数有： `encoding` ， `strip_whitespace` ， `strip_text` 等。参见下面。

- `value1` , `value2` 等： 参数的值。必须是一个常量表达式(如 `true`， 或 `"ISO-8859-5"`，或 `{x:1, y:2}`)。它不能用变量。

### 描述

告诉 FreeMarker 和其他工具关于模板的信息， 而且帮助程序员来自动检测一个文本文件是否是 FTL 文件。该指令， 如果存在，必须是模板的第一句代码。该指令前的任何 空白 将被忽略。 该指令的老式语法(#-less)格式是不支持的。

一些设置(编码方式，空白剥离等)在这里给定的话就有最高的优先级， 也就是说，它们直接作用于模板而不管其他任何 FreeMarker 的配置设置。

### 参数

- encoding： 使用它，你可以在模板文件本身中为模板指定编码方式(字符集) (也就是说，这是新创建 Template 的 encoding 设置， 而且 Configuration.getTemplate 中的 encoding 参数不能覆盖它)。要注意， FreeMarker 会尝试会和自动猜测的编码方式 (这依赖于程序员对 FreeMarker 的配置)找到 ftl 指令并解释它，然后就会发现 ftl 指令会让一些东西有所不同，之后以新的编码方式来重新读取模板。 因此，直到 ftl 标记使用第一个编码方式读取到结尾， 模板必须是合法的FTL。 这个参数的合法值是从IANA字符集注册表中参考MIME中的字符集名称。 比如 ISO-8859-5，UTF-8 或 Shift_JIS。

- strip_whitespace： 这将开启/关闭 空白剥离。 合法的值是布尔值常量 true 和 false (为了向下兼容，字符串 "yes"，"no"， "true"，"false" 也是可以的)。 默认值(也就是当你不使用这个参数时)是依赖于程序员对 FreeMarker 的配置， 但是对新的项目还应该是 true。

- strip_text：当开启它时， 当模板被解析时模板中所有顶级文本被移除。这个不会影响宏，指令，或插值中的文本。 合法值是布尔值常量 true 和 false (为了向下兼容，字符串 "yes"，"no"， "true"，"false" 也是可以的)。 默认值(也就是当你不使用这个参数时)是 false。

- strict_syntax：这会开启/关闭"严格的语法"。 合法值是布尔值常量 true 和 false (为了向下兼容，字符串 "yes"，"no"， "true"，"false" 也是可以的)。 默认值(也就是当你不使用这个参数时)是依赖于程序员对 FreeMarker 的配置， 但是对新的项目还应该是 true。(程序员：对于 config.setStrictSyntaxMode(true); 你必须明确设置它为 true) 要获取更多信息，可以参考：废弃的 FTL 结构/老式 FTL 语法

- attributes：这是关联模板任意属性(名-值对)的哈希表。 属性的值可以是任意类型(字符串，数字，序列等)。FreeMarker 不会尝试去理解属性的含义。 它是由封装 FreeMarker(比如Web应用框架)的应用程序决定的。 因此，允许的属性的设置是它们依赖的应用(Web应用框架)的语义。 程序员：你可以通过关联 Template 对象的 getCustomAttributeNames 和 getCustomAttribute 方法 (从 freemarker.core.Configurable 继承而来)获得属性。 如当模板被解析时，关联 Template 对象的模板属性， 属性可以在任意时间被读取，而模板不需要被执行。 上面提到的方法返回未包装的属性值，也就是说， 使用 FreeMarker 独立的类型，如 java.util.List。

---

## function, return

### 概要

```
<#function name param1 param2 ... paramN>
  ...
  <#return returnValue>
  ...
</#function>
```

#### 这里:

- `name`：方法变量的名称(不是表达式)

- `param1`, `param2` 等： 局部变量的名称， 存储参数的值(不是表达式)，在 `=` 号后面和默认值 (是表达式)是可选的。

- `paramN`，最后一个参数， 可以可选的包含一个尾部省略(...)， 这就意味着宏接受可变的参数数量。局部变量 `paramN` 将是额外参数的序列。

- `returnValue：` 计算方法调用值的表达式。

`return` 指令可以在 `<#function ...>` 和 `</#function>` 之间被用在任意位置和任意次数。

没有默认值的参数必须在有默认值参数 (`paramName=defaultValue`) 之前

### 描述

创建一个方法变量(在当前命名空间中，如果你知道命名空间的特性)。 这个指令和 `macro` 指令 的工作方式一样，除了 `return` 指令必须有一个参数来指定方法的返回值，而且视图写入输出的将会被忽略。 如果到达 `</#function>` (也就是说没有 `return returnValue`)， 那么方法的返回值就是未定义变量。

示例1：创建一个方法来计算两个数的平均值：

```
<#function avg x y>
  <#return (x + y) / 2>
</#function>
${avg(10, 20)}
```

将会输出：

```
15
```

示例2：创建一个方法来计算多个数的平均值：

```
<#function avg nums...>
  <#local sum = 0>
  <#list nums as num>
    <#local sum = sum + num>
  </#list>
  <#if nums?size != 0>
    <#return sum / nums?size>
  </#if>
</#function>
${avg(10, 20)}
${avg(10, 20, 30, 40)}
${avg()!"N/A"}
```

将会输出：

```
15
25
N/A
```

---

## global

### 概要

```
<#global name=value>
```
或
```
<#global name1=value1 name2=value2 ... nameN=valueN>
```
或
```
<#global name>
  capture this
</#global>
```

#### 这里：

- `name`：变量的名称。 它不是表达式。但它可以被写作是字符串形式，如果变量名包含保留字符这是很有用的， 比如 `<#global "foo-bar" = 1>`。 注意这个字符串没有扩展插值(如 "`${foo}`")。

- `=`：赋值操作符，也可以简写的赋值操作符之一 (`++`， `+=`，等...)，和 `assign` 指令 相似

- `value`：存储的值，是表达式。

### 描述

该指令和 `assign` 相似， 但是被创建的变量在所有的 命名空间 中都可见， 但又不会存在于任何一个命名空间之中。精确地说，正如你会创建 (或替换)一个数据模型变量。因此，这个变量是全局的。如果在数据模型中， 一个相同名称的变量存在的话，它会被使用该指令创建的变量隐藏。 如果在当前的命名空间中，一个相同名称的变量存在的话， 那么会隐藏由 `global` 指令创建的变量。

例如，用 `<#global x = 1>` 创建一个变量， 那么在所有命名空间中 `x` 都可见， 除非另外一个称为 `x` 的变量隐藏了它 (比如你已经用 `<#assign x = 2>` 创建了一个变量)。 这种情形下，你可以使用 特殊变量 `globals`，比如 `${.globals.x}`。请注意， 使用 `globals` 你看到所有全局可访问的变量； 不但由 `global` 指令创建的变量，而且是数据模型中的变量。

自定义JSP标记的用户请注意：用这个指令创建的变量集合和JSP页面范围对应。 这就意味着，如果自定义JSP标记想获得一个页面范围的属性(page-scope bean)， 在当前命名空间中一个相同名称的变量，从JSP标记的观点出发，将不会隐藏。

---

## if, else, elseif

### 概要

```
<#if condition>
  ...
<#elseif condition2>
  ...
<#elseif condition3>
  ...
...
<#else>
  ...
</#if>
```

#### 这里：

- `condition`, `condition2`， 等：将被计算成布尔值的表达式。

`elseif` 和 `else` 是可选的。

### 描述

你可以使用 `if`， `elseif` 和 `else` 指令来条件判断是否越过模板的一个部分。 `condition` 必须计算成布尔值， 否则错误将会中止模板处理。`elseif` 和 `else` 必须出现在 `if` 内部 (也就是，在 `if` 的开始标签和结束标签之间)。 `if` 中可以包含任意数量的 `elseif`(包括0个) 而且结束时 `else` 是可选的。

```
<#if x == 1>
  x is 1
<#elseif x == 2>
  x is 2
<#elseif x == 3>
  x is 3
<#elseif x == 4>
  x is 4
<#else>
  x is not 1 nor 2 nor 3 nor 4
</#if>
```

嵌套 if 指令：

```
<#if x == 1>
  x is 1
  <#if y == 1>
    and y is 1 too
  <#else>
    but y is not
  </#if>
<#else>
  x is not 1
  <#if y < 0>
    and y is less than 0
  </#if>
</#if>
```

> 当你想测试是否 `x > 0` 或 `x >= 0`，编写 `<#if x > 0>` 和 `<#if x >= 0>` 是错误的， 因为第一个 `>` 会结束 `#if` 标签。要这么来做，可以编写 `<#if x gt 0> `或 `<#if gte 0>`。也请注意，如果比较发生在括号内部，那么就没有这样的问题， 比如 `<#if foo.bar(x > 0)>` 就会得到想要的结果。

---

## import

